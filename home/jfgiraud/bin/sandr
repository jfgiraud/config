#!/bin/bash -i

function usage() {
	cat <<-EOF
NAME:

        ${0##*/} - perform pattern replacement in files

SYNOPSYS:

        ${0##*/}
             -h, --help           display help
             -s, --search         the string to search
             -S, --search-regex   the pattern to search
             -r, --replace        the string (or the pattern) used to replace all matches 
             -e, --extract-map    extract from file or standart input all matches of searched
                                  string or pattern.
                                  a map created with found matches is displayed on standart 
                                  output. entries of this map will be setted with a default
                                  value
             -a, --apply-map      use a map to perform replacement
             -t, --simulate       perform a simulation for replacements
                                  the results will be displayed on standart output
             -c, --confirm        prompt before applaying replacements on files
                                  
        
With no FILE, or when FILE is -, read standard input.

AUTHOR
	Written by Jean-François Giraud.

COPYRIGHT
	Copyright © 2012-2014 Jean-François Giraud.  License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.

EOF
	exit 0
}

function error() {
    STATUS="$1"
    MSG="$2"
    cat >&2 <<-EOF
${0##*/}: $MSG
Try \`${0##*/} -h\` for more information.
EOF
    exit 1
}

function replace() {
    local useregexp="$1"
    local search="$2"
    local replace="$3"
    local script=$(mktemp)
    cat > $script <<'EOF'
#!/usr/bin/perl -w
use strict;
my $useregexp = ($ARGV[0] eq "true" ? 1 : 0);
my $search=$ARGV[1];
my $replace=$ARGV[2];
if ($useregexp) {
    $replace = '"' . $replace . '"'
} else {
    $search = quotemeta($search);
}
while (<STDIN>) {
    if ($useregexp) { 
        s/$search/$replace/gee;
    } else {
        s/$search/$replace/g;
    }
    print;
}
EOF
    perl $script "$useregexp" "$search" "$replace"
    rm -f $script
}



PARAMS=$(getopt -o "s:S:r:tcea:h" -l "search:,search-regex:,replace:,simulate,confirm,extract-map,apply-map:,help" -- "$@")

eval set -- "$PARAMS"

mode="no-confirm"
sflag=false
while [ "X$1" != "X--" ]; do
    case "$1" in
	-s|--search)
	    shift
	    search="$1"
	    ;;
	-S|--search-regex)
	    shift
	    search="$1"
	    sflag=true
	    ;;
	-r|--replace)
	    shift 
	    replace="$1"
	    ;;
	-t|--simulate)
	    if [ -v eflag ]; then
		error 1 "setting option --simulate makes no sense with option --extract-map"
	    fi
	    mode="dry-run"
	    ;;
	-c|--confirm)
	    if [ -v eflag ]; then
		error 1 "setting option --confirm makes no sense with option --extract-map"
	    fi
	    mode="confirm"
	    ;;
	-e|--extract-map)
	    if [ -n "$mapping" ]; then
		error 1 "--extract-map and --apply-map option are mutually exclusives"
	    fi
	    eflag=1
	    ;;
	-a|--apply-map)
	    if [ -v eflag ]; then
		error 1 "--extract-map and --apply-map option are mutually exclusives"
	    fi
	    shift
	    mapping="$1"
	    ;;
	-h|--help)
	    usage
	    ;;
    esac
    shift
done

shift

if [ $# -eq 0 ]; then
    if [ -t 0 ]; then
	usage 
    fi
fi

if [ -v eflag -a -z "$search" ]; then
    error 1 "setting option --extract-map implies to set options --search and --replace"
fi

if [ -n "$eflag" ]; then
    if [ "$sflag" == "true" ]; then
	grepopt="E"
    fi
    cat $* | grep -${grepopt}i "${search}" -o | sort -u | while read match || [[ $match ]]; do
	if [ "$sflag" == "true" ]; then
	    echo "$match:$replace"
	else
	    c=${match:0:1}
	    s=${match:1}
	    sc=${search:0:1}
	    ss=${search:1}
	    rc=${replace:0:1}
	    rs=${replace:1}
	    if [ "${match}" == "${search}" ]; then
		echo "$match:${replace}"	
	    elif [ "${match}" == "${search,,}" ]; then
		echo "$match:${replace,,}"
	    elif [ "${match}" == "${search^^}" ]; then
		echo "$match:${replace^^}"
	    elif [ "${match}" == "${search~~}" ]; then
		echo "$match:${replace~~}"
	    elif [ "${match}" == "${search,}" ]; then
		echo "$match:${replace,}"
	    elif [ "${match}" == "${search^}" ]; then
		echo "$match:${replace^}"
	    elif [ "${c^}${s,,}" == "${sc^}${ss,,}" ]; then
		echo "$match:${rc^}${rs,,}"
	    else
		echo "$match:"
	    fi
	fi
    done
    exit 0
fi

file="$1"
if [ -z $file ]; then
    file="-"
fi

if [ "$mode" == "confirm" ]; then
    confirm=-i
fi

while [ -n "$file" ];
do
    tmp=$(mktemp)
    ori=$(mktemp)
    if [ -z "$mapping" ]; then
	cat "$file" | tee $ori | replace "$sflag" "${search}" "${replace}" > $tmp
    else
	cat "$file" > $ori 
	cat $ori | eval $(tac z | awk -F ':' -v q="'" 'BEGIN{ print "sed" } { printf "-e %cs:%s:%s:g%c ", q, $1, $2,q }' | tr '\n' ' ') > $tmp
    fi
    if [ "$mode" == "dry-run" ]; then 
	if ! diff "$ori" "$tmp" &> /dev/null; then
	    if [ "$file" == "-" ]; then
		file="(stdin)"
	    fi
	    printf -v separator "%*s " $(( $(tput cols) - ${#file} - 5 ))
	    echo "-- $file ${separator// /-}"
	    diff --suppress-common-lines -y -W $(tput cols) "$ori" "$tmp"
	    echo
	fi
    else
	if [ "$file" != "-" ]; then
	    if ! diff "$file" "$tmp" &> /dev/null; then
		cp $confirm "$tmp" "$file"
	    fi
	else
	    cat $tmp
	fi
    fi
    rm -f "$tmp" "$ori"
    shift
    file="$1"
done

exit 0
