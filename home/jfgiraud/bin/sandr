#!/bin/bash -i

usage() {
	cat <<-EOF
NAME:

        ${0##*/} - perform pattern replacement in files

SYNOPSYS:

        ==== Display help

        ${0##*/} -h ...
        -h                        display help

        ==== Replace with SED expressions

        ${0##*/} [ -d | -c | -t ] <SEARCH> <REPLACE> FILE ...
        -t                        simulates replacement. Print results on the standard output
        -c                        when files differ, prompt confirmation before overwrite
        -d                        apply replacement in files 
        <SEARCH>                  the string or the pattern to search
        <REPLACE>                 the string or the pattern used to replace all matches 

        ==== Extract and initialize a map translation

        ${0##*/} -e <SEARCH> <REPLACE> FILE ...
        -e                        extract from files all matches of <SEARCH> (string) ignoring case.
                                  initialize a map (key:value) on the standard output which can be 
                                  writed in file and completed to be used later.
        <SEARCH>                  the string to search ignoring case. All distinct matches will be
                                  a key of the map.
        <REPLACE>                 the string used to replace matches. it is used to help to initialize
                                  the values of the map (case modifications can be done)

        ==== Replace using a map translation file

        ${0##*/} -f <MAP> FILE ...
        -f                        replace all matches of keys in the (key:value) pairs of the map file
                                  with the corresponding value.
        -t                        simulates replacement. Print results on the standard output
        -c                        when files differ, prompt confirmation before overwrite
        
With no FILE, or when FILE is -, read standard input.

AUTHOR
	Written by Jean-François Giraud.

COPYRIGHT
	Copyright © 2012-2014 Jean-François Giraud.  License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.

EOF
	exit 0
}

error() {
    STATUS="$1"
    MSG="$2"
    cat >&2 <<-EOF
${0##*/}: $MSG
Try \`${0##*/} -h\` for more information.
EOF
    exit 1
}

if [ $# -eq 0 ]; then
    if [ -t 0 ]; then
	usage 
    else
	error 1 "Missing parameters!" 
    fi
fi

mode="no-confirm"
change_mode() {
    if [ $mode == "no-confirm" ]; then
        mode="confirm"
    elif [ $mode == "confirm" ]; then
        mode="dry-run"
    else
        mode="dry-run"
    fi
}

while getopts :hces:r:f: o
do
    case "$o" in
    h) usage ;;
    c) change_mode ;;
    e) extflag=1 ;;
    f) mapping="$OPTARG" ;;
    s) search="$OPTARG" ;;
    r) replace="$OPTARG" ;;
    ?) error 1 "invalid option '$OPTARG'" ;;        
    esac
done


if [[ -n "$extflag" && -n "$mapping" ]]; then
    error 1 "option -e and -f are mutually exclusives"
elif [[ -n "$extflag" && "$mode" != "no-confirm" ]]; then
    error 1 "setting option -e makes no sense with option -c or -cc"
elif [[ -n "$extflag" ]] && [[ -z "$search" || -z "$replace" ]]; then
    error 1 "setting option -e implies to set option -s and -r"
fi

shift $(( $OPTIND - 1 ))

if [ -n "$extflag" ]; then
    cat $* | grep -i "${search}" -o | sort -u | awk -v src="${search}" -v dst="${replace}" '{ 
            ori=$0
            fl=substr(ori,0,1)
            slaf=substr(ori,2)
            if (ori==src) 
               print ori ":" dst;
            else if (tolower(ori)==ori)
               print ori ":" tolower(dst);
            else if (toupper(ori)==ori)
               print ori ":" toupper(dst);
            else if (ori == toupper(fl) tolower(slaf))
               print ori ":" toupper(substr(dst,0,1)) tolower(substr(dst,2));
            else
               print ori ":" ;
             }
    ' | sort -u
    exit 0
fi

file="$1"
if [ -z $file ]; then
        file="-"
fi

if [ "$mode" == "confirm" ]; then
    confirm=-i
fi

while [ -n "$file" ];
do
    tmp=$(mktemp)
    ori=$(mktemp)
    if [ -z "$mapping" ]; then
	cat "$file" | tee $ori | sed -e "s:${search//:/\\:}:${replace//:/\\:}:g" > $tmp
    else
	cat "$file" > $ori 
        awk -F':' 'function ltrim(s) { sub(/^[ \t\r\n]+/, "", s); return s }
            function rtrim(s) { sub(/[ \t\r\n]+$/, "", s); return s }
            function trim(s) { return rtrim(ltrim(s)); } 
            NR==FNR {a[$1]=trim($2);next} {for (i in a) gsub(i,a[i])} 1' "$mapping" $ori > $tmp
    fi
    if [ "$mode" == "dry-run" ]; then 
	if [ "$file" == "-" ]; then
	    file="(stdin)"
	fi
	printf -v separator "%*s " $(( $(tput cols) - ${#file} - 5 ))
	echo "-- $file ${separator// /-}"
	if ! diff "$ori" "$tmp" &> /dev/null; then
	    diff --suppress-common-lines -y -W $(tput cols) "$ori" "$tmp"
	fi
	echo
    else
	if [ "$file" != "-" ]; then
	    if ! diff "$file" "$tmp" &> /dev/null; then
		cp $confirm "$tmp" "$file"
	    fi
	else
	    cat $tmp
	fi
    fi
    rm -f "$tmp" "$ori"
    shift
    file="$1"
done

exit 0
